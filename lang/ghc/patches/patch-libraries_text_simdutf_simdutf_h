https://github.com/simdutf/simdutf/commit/55b107f609f5f63880db650a92861ae84cb10abe
(haskell/text upstream has now updated to a version past this commit)

Index: libraries/text/simdutf/simdutf.h
--- libraries/text/simdutf/simdutf.h.orig
+++ libraries/text/simdutf/simdutf.h
@@ -549,6 +549,7 @@ namespace cpuid_bit {
     // EAX = 0x01
     constexpr uint32_t pclmulqdq = uint32_t(1) << 1; ///< @private bit  1 of ECX for EAX=0x1
     constexpr uint32_t sse42 = uint32_t(1) << 20;    ///< @private bit 20 of ECX for EAX=0x1
+    constexpr uint32_t osxsave = (uint32_t(1) << 26) | (uint32_t(1) << 27); ///< @private bits 26+27 of ECX for EAX=0x1
 
     // EAX = 0x7f (Structured Extended Feature Flags), ECX = 0x00 (Sub-leaf)
     // See: "Table 3-8. Information Returned by CPUID Instruction"
@@ -574,6 +575,10 @@ namespace cpuid_bit {
     namespace edx {
       constexpr uint32_t avx512vp2intersect = uint32_t(1) << 8;
     }
+    namespace xcr0_bit {
+      constexpr uint64_t avx256_saved = uint64_t(1) << 2; ///< @private bit 2 = AVX
+      constexpr uint64_t avx512_saved = uint64_t(7) << 5; ///< @private bits 5,6,7 = opmask, ZMM_hi256, hi16_ZMM
+    }
   }
 }
 
@@ -583,7 +588,7 @@ static inline void cpuid(uint32_t *eax, uint32_t *ebx,
                          uint32_t *edx) {
 #if defined(_MSC_VER)
   int cpu_info[4];
-  __cpuid(cpu_info, *eax);
+  __cpuidex(cpu_info, *eax, *ecx);
   *eax = cpu_info[0];
   *ebx = cpu_info[1];
   *ecx = cpu_info[2];
@@ -601,6 +606,16 @@ static inline void cpuid(uint32_t *eax, uint32_t *ebx,
 #endif
 }
 
+static inline uint64_t xgetbv() {
+#if defined(_MSC_VER)
+  return _xgetbv(0);
+#else
+  uint32_t xcr0_lo, xcr0_hi;
+  asm volatile("xgetbv\n\t" : "=a" (xcr0_lo), "=d" (xcr0_hi) : "c" (0));
+  return xcr0_lo | ((uint64_t)xcr0_hi << 32);
+#endif
+}
+
 static inline uint32_t detect_supported_architectures() {
   uint32_t eax;
   uint32_t ebx = 0;
@@ -620,6 +635,16 @@ static inline uint32_t detect_supported_architectures(
     host_isa |= instruction_set::PCLMULQDQ;
   }
 
+  if ((ecx & cpuid_bit::osxsave) != cpuid_bit::osxsave) {
+    return host_isa;
+  }
+
+  // xgetbv for checking if the OS saves registers
+  uint64_t xcr0 = xgetbv();
+
+  if ((xcr0 & cpuid_bit::xcr0_bit::avx256_saved) == 0) {
+    return host_isa;
+  }
   // ECX for EAX=0x7
   eax = 0x7;
   ecx = 0x0; // Sub-leaf = 0
@@ -632,6 +657,9 @@ static inline uint32_t detect_supported_architectures(
   }
   if (ebx & cpuid_bit::ebx::bmi2) {
     host_isa |= instruction_set::BMI2;
+  }
+  if (!((xcr0 & cpuid_bit::xcr0_bit::avx512_saved) == cpuid_bit::xcr0_bit::avx512_saved)) {
+    return host_isa;
   }
   if (ebx & cpuid_bit::ebx::avx512f) {
     host_isa |= instruction_set::AVX512F;
