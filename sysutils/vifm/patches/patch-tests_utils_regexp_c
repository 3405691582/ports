Don't hard-code OS X, do a runtime behaviour check.

Index: tests/utils/regexp.c
--- tests/utils/regexp.c.orig
+++ tests/utils/regexp.c
@@ -2,7 +2,7 @@
 
 #include "../../src/utils/regexp.h"
 
-static int not_osx(void);
+static int has_empty_regexps(void);
 
 TEST(bad_regex_leaves_line_unchanged)
 {
@@ -10,10 +10,8 @@ TEST(bad_regex_leaves_line_unchanged)
 			regexp_replace("barfoobar", "*foo", "z", 1, 0));
 }
 
-TEST(no_infinite_loop_on_empty_global_match, IF(not_osx))
+TEST(no_infinite_loop_on_empty_global_match, IF(has_empty_regexps))
 {
-	/* On OS X, regular expressions which can match empty strings don't
-	 * compile. */
 	assert_string_equal("zbarfoobar", regexp_replace("barfoobar", "", "z", 1, 0));
 }
 
@@ -45,13 +43,18 @@ TEST(back_reference_substitution)
 }
 
 static int
-not_osx(void)
+has_empty_regexps(void)
 {
-#ifndef __APPLE__
-	return 1;
-#else
-	return 0;
-#endif
+	/* At least on OS X and OpenBSD, regular expressions which can match empty
+	 * strings don't compile. */
+	regex_t re;
+	int err = regcomp(&re, "", /*cflags=*/0);
+	if(err == 0)
+	{
+		err = regexec(&re, "bla", /*nmatch=*/0, /*pmatch=*/NULL, /*eflags=*/0);
+		regfree(&re);
+	}
+	return (err == 0);
 }
 
 /* vim: set tabstop=2 softtabstop=2 shiftwidth=2 noexpandtab cinoptions-=(0 : */
