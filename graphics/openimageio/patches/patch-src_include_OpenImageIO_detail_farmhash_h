Revert fix(strutil.h): ensure proper constexpr of string hashing (#3901)
8e8dab1215f584ff940ea6240768abecd5c63f07

Index: src/include/OpenImageIO/detail/farmhash.h
--- src/include/OpenImageIO/detail/farmhash.h.orig
+++ src/include/OpenImageIO/detail/farmhash.h
@@ -244,77 +244,21 @@ STATIC_INLINE uint32_t Fetch32(const char *p) {
 
 #else
 
-#if defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806L
-// C++20 compiler with constexpr support std::bitcast
-STATIC_INLINE uint64_t Fetch64(const char *p) {
-  struct BlockOfBytes {
-    char bytes[8];
-  };
-  BlockOfBytes bob{p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]};
-  return std::bit_cast<uint64_t>(bob);
+template <typename T>
+STATIC_INLINE T FetchType(const char *p) {
+  T result = 0;
+  for (size_t i = 0; i < sizeof(T); i++)
+      reinterpret_cast<char *>(&result)[i] = p[i];
+  return result;
 }
-STATIC_INLINE uint32_t Fetch32(const char *p) {
-  struct BlockOfBytes {
-    char bytes[4];
-  };
-  BlockOfBytes bob{p[0],p[1],p[2],p[3]};
-  return std::bit_cast<uint32_t>(bob);
-}
 
-#else
-
-// constexpr supported for C++14,17 versions that manually load bytes and
-// bitshift into proper order for the unsigned integer.
-// NOTE: bigendian untested
 STATIC_INLINE uint64_t Fetch64(const char *p) {
-    // Favor letting uint8_t construction to handle
-    // signed to unsigned conversion vs. uint64_t(p[0]&0xff)
-    uint8_t b0 = p[0];
-    uint8_t b1 = p[1];
-    uint8_t b2 = p[2];
-    uint8_t b3 = p[3];
-    uint8_t b4 = p[4];
-    uint8_t b5 = p[5];
-    uint8_t b6 = p[6];
-    uint8_t b7 = p[7];
-    return littleendian() ?
-        (uint64_t(b0))       | // LSB
-        (uint64_t(b1) <<  8) |
-        (uint64_t(b2) << 16) |
-        (uint64_t(b3) << 24) |
-        (uint64_t(b4) << 32) |
-        (uint64_t(b5) << 40) |
-        (uint64_t(b6) << 48) |
-        (uint64_t(b7) << 56)   // MSB
-      : // Big Endian byte order
-        (uint64_t(b0) << 56) |  // MSB
-        (uint64_t(b1) << 48) |
-        (uint64_t(b2) << 40) |
-        (uint64_t(b3) << 32) |
-        (uint64_t(b4) << 24) |
-        (uint64_t(b5) << 16) |
-        (uint64_t(b6) <<  8) |
-        (uint64_t(b7)) ;       // LSB
+  return FetchType<uint64_t>(p); 
 }
 
 STATIC_INLINE uint32_t Fetch32(const char *p) {
-    uint8_t b0 = p[0];
-    uint8_t b1 = p[1];
-    uint8_t b2 = p[2];
-    uint8_t b3 = p[3];
-    return littleendian() ?
-        (uint32_t(b0))       | // LSB
-        (uint32_t(b1) <<  8) |
-        (uint32_t(b2) << 16) |
-        (uint32_t(b3) << 24)   // MSB
-      : // Big Endian byte order
-        (uint32_t(b0) << 24) | // MSB
-        (uint32_t(b1) << 16) |
-        (uint32_t(b2) <<  8) |
-        (uint32_t(b3));        // LSB
+  return FetchType<uint32_t>(p);
 }
-#endif
-
 
 // devices don't seem to have bswap_64() or bswap_32()
 template<typename T>
