Add patches from https://github.com/Icinga/icinga2/pull/9518;
this changes things so that icinga reloads work properly with OpenBSD
(which doesn't fill in si_pid in siginfo_t so that icinga doesn't know
which process exited).

[PATCH 1/3] StartUnixWorker(): watch forked child via waitpid(), not SIGCHLD handler
[PATCH 2/3] Remove unused UnixWorkerState::Failed
[PATCH 3/3] icinga2 daemon: remove no-op SIGCHLD handling

Index: lib/cli/daemoncommand.cpp
--- lib/cli/daemoncommand.cpp.orig
+++ lib/cli/daemoncommand.cpp
@@ -330,8 +330,7 @@ int RunWorker(const std::vector<std::string>& configs,
 enum class UnixWorkerState : uint_fast8_t
 {
 	Pending,
-	LoadedConfig,
-	Failed
+	LoadedConfig
 };
 
 // The signals to block temporarily in StartUnixWorker().
@@ -339,7 +338,6 @@ static const sigset_t l_UnixWorkerSignals = ([]() -> s
 	sigset_t s;
 
 	(void)sigemptyset(&s);
-	(void)sigaddset(&s, SIGCHLD);
 	(void)sigaddset(&s, SIGUSR1);
 	(void)sigaddset(&s, SIGUSR2);
 	(void)sigaddset(&s, SIGINT);
@@ -381,13 +379,6 @@ static void UmbrellaSignalHandler(int num, siginfo_t *
 				l_CurrentlyStartingUnixWorkerState.store(UnixWorkerState::LoadedConfig);
 			}
 			break;
-		case SIGCHLD:
-			if (l_CurrentlyStartingUnixWorkerState.load() == UnixWorkerState::Pending
-				&& (info->si_pid == 0 || info->si_pid == l_CurrentlyStartingUnixWorkerPid.load()) ) {
-				// The seamless worker currently being started by StartUnixWorker() failed
-				l_CurrentlyStartingUnixWorkerState.store(UnixWorkerState::Failed);
-			}
-			break;
 		case SIGINT:
 		case SIGTERM:
 			// Someone requested our termination
@@ -483,7 +474,7 @@ static pid_t StartUnixWorker(const std::vector<std::st
 	}
 
 	/* Block the signal handlers we'd like to change in the child process until we changed them.
-	 * Block SIGUSR2 and SIGCHLD handlers until we've set l_CurrentlyStartingUnixWorkerPid.
+	 * Block SIGUSR2 handler until we've set l_CurrentlyStartingUnixWorkerPid.
 	 */
 	(void)sigprocmask(SIG_BLOCK, &l_UnixWorkerSignals, nullptr);
 
@@ -513,7 +504,6 @@ static pid_t StartUnixWorker(const std::vector<std::st
 
 					sa.sa_handler = SIG_DFL;
 
-					(void)sigaction(SIGCHLD, &sa, nullptr);
 					(void)sigaction(SIGUSR1, &sa, nullptr);
 					(void)sigaction(SIGHUP, &sa, nullptr);
 				}
@@ -570,28 +560,21 @@ static pid_t StartUnixWorker(const std::vector<std::st
 				NotifyWatchdog();
 #endif /* HAVE_SYSTEMD */
 
-				switch (l_CurrentlyStartingUnixWorkerState.load()) {
-					case UnixWorkerState::LoadedConfig:
-						Log(LogNotice, "cli")
-							<< "Worker process successfully loaded its config";
-						break;
-					case UnixWorkerState::Failed:
-						Log(LogNotice, "cli")
-							<< "Worker process couldn't load its config";
+				if (waitpid(pid, nullptr, WNOHANG) > 0) {
+					Log(LogNotice, "cli")
+						<< "Worker process couldn't load its config";
 
-						while (waitpid(pid, nullptr, 0) == -1 && errno == EINTR) {
-#ifdef HAVE_SYSTEMD
-							NotifyWatchdog();
-#endif /* HAVE_SYSTEMD */
-						}
-						pid = -2;
-						break;
-					default:
-						Utility::Sleep(0.2);
-						continue;
+					pid = -2;
+					break;
 				}
 
-				break;
+				if (l_CurrentlyStartingUnixWorkerState.load() == UnixWorkerState::LoadedConfig) {
+					Log(LogNotice, "cli")
+						<< "Worker process successfully loaded its config";
+					break;
+				}
+
+				Utility::Sleep(0.2);
 			}
 
 			// Reset flags for the next time
@@ -734,7 +717,6 @@ int DaemonCommand::Run(const po::variables_map& vm, co
 		sa.sa_sigaction = &UmbrellaSignalHandler;
 		sa.sa_flags = SA_NOCLDSTOP | SA_RESTART | SA_SIGINFO;
 
-		(void)sigaction(SIGCHLD, &sa, nullptr);
 		(void)sigaction(SIGUSR1, &sa, nullptr);
 		(void)sigaction(SIGUSR2, &sa, nullptr);
 		(void)sigaction(SIGINT, &sa, nullptr);
